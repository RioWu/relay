# 前言

首先祝小伙伴们新年好！经过一学期的学习，不知道你们对之前的培养方案掌握了多少，如果你们都按部就班的完成了，想必现在也有一定的开发能力了。之后也会有几个工作室内部的项目需要后台组成员的参与，大家也可以积极参与。

# Java学习建议

之前考虑过后端除了php以外再学习一门Java，这边先给一些Java的入门知识的学习要点，如果**有兴趣**的可以参考一下，之后可能会考虑用Java做一些项目。

## 建议书籍

    1. Java核心技术卷1（3-6章，11-14章）+ IO + JDBC + 网络（这三部分在Java核心技术卷二）；
    2. 如果感觉对卷1里的并发部分理解的不是很好，可以参考《Java并发编程的艺术》，并发是Java中很重要的一部分，要好好掌握；
    2. 深入理解Java虚拟机：第二部分，第6、7章，第五部分；
    3. Mysql必知必会：前21章+第26章；
    4. SSM(Spring SpringMVC Mybatis)：随便找本书看看就行，先做到理解基本的概念，会用。Spring是重中之重；
    5. 数据结构、算法：算法（第4版），很好的一本算法入门书籍，全书都是用Java语言编写，适合用来初步接触算法，或者打基础用。另外有兴趣的可以去做一些题目，牛客网或者leetcode都可以选择。
## 系统环境

```
1.JVM 1.8（主流公司使用的版本，不过不必拘泥于版本细节，Java的主体框架几乎没什么改变）
2.项目管理工具：maven/grandle
3.版本控制工具：git/svn
4.数据库：mysql/mongodb...
5.IDE：IDEA/Eclipse
上面的几个内容都不是指定必须要用哪一个，比如如果你不喜欢maven复杂、冗长的语法，可以考虑grandle；IDE也可以选择Eclipse，这个都见仁见智了，用哪个的都有，不过IDEA是JetBrains的产品，有学生认证这个福利可以用。
这几个都算比较常用的了，随便选择一种学习吧，如果实在不知道选哪个，就选前面那种（个人建议哈）
```

## Java基础

- Java执行过程（.java文件->.class文件->jvm运行字节码文件）、Java的组成(jre/jdk)

- 八种基本类型及其对应的对象（自动装箱、自动拆箱）

  - 类型转换时可能出现的精度问题

  - 关于类型转换的例子

    ```java
    int a = 4;
    float b = 6;
    a += b;		//方法1
    a = a + b;	//方法2
    ```

    方法1和方法2的区别是什么？两种方法都能成功使 a = a + b吗？如果不能，为什么？

- Java字符串（String）

  - String为什么是不可变的？
  - StringBuffer和StringBuilder两种字符串构建器
  - String对equals方法的重写

- Java中的关于函数参数的调用——总是按值传递

## 面向对象基础

- 基本概念，面向对象和面向过程各自的优缺点
- 面向对象的三大特征
  - 封装（public、protected、private）
  - 继承（逻辑复用）
  - 多态（方法重写）
- 对象初始化步骤：静态成员变量>静态初始化块>成员变量>初始化块>构造方法
- 方法
  - 了解方法的签名：方法名+参数类型列表
  - 方法的重载
- 继承
  - 构造函数的继承（一个类如果没有声明构造函数，会默认提供一个无参构造函数（默认构造函数），子类的构造方法要调用父类的构造方法，不显式写的话就会调用父类的默认构造函数，如果父类没有默认构造函数，无法通过编译）
- Object：所有类的超类
  - 几个重要的方法：equals()、hashCode()、toString()
  - 这几个方法分别的作用，以及在平常使用中如何对这些方法进行重写
- Interface（接口）：
  - 接口和抽象类(abstract Class)的区别和联系
- clone（对象克隆）：
  - Cloneable接口，标记接口
    - 什么是标记接口？ 答：实际上标记接口是没有内容的，只是用来对一个对象进行某种标注
  - 什么是深克隆与浅克隆？
    - 可以尝试一下利用序列化的方法实现深克隆
- reflection（反射）：提供了"运行时"分析以及操纵类和对象的能力

## 集合

- 这个部分跟数据结构联系比较多，有不清楚的可以去网上找找资料，不要太多。

- 接口：Collection、List、Set、Map、Iterator
- 几个重要的实现类：ArrayList、LinkedList（和数组的区别，他们之间的区别）、Vector
  HashMap、TreeMap、LinkedHashMap
- HashMap
  - Hash函数（散列函数）
    - Hash的具体实现
      - 使用Key对象的hashCode方法
      - 高低位异或，增大随机性（扰动），避免Key对象散列函数的缺陷
      - 计算出hash值之后，用数组长度对结果进行取余，获得最终存放位置（解释了为什么HashMap的长度必须是2^n）
    - 处理冲突的方法：开放地址法和拉链法
    - HashMap的扩容
  - equals和hashCode方法的重写问题：重写equals后，一般都要重写hashCode，保证两个对象相等时，他们的hashCode也是相等的。
- 范型：常和集合类一起使用。让错误在编译期就暴露而避免在JVM运行时出错
  - 可以使用的范围：类、方法、接口
  - 类型擦除，桥接

